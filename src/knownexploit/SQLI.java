package knownexploit;

import java.util.ArrayList;

import app.App;
import entrypoint.EntryPoint;
import entrypoint.SQLIEntryPoint;
import sink.SQLISink;
import sink.Sink;

public class SQLI extends KnownExploit{

	public SQLI(ArrayList<String> codeLines){
		super("Configs/SQLI.xml", codeLines, "SQL Injection");
	}
	
	@Override
	public boolean testVunerability() {
		Boolean vunerability = false;
		if(!_sinks.isEmpty()){	
			String query = "";
			
			for(Sink s : _sinks){
				
				if(_querys.containsKey(s.getFirstArgument())){
					query = _querys.get(s.getFirstArgument());
					
					for(EntryPoint e : _eps){
						
						if(query.contains(e.getEpVariable())){
							vunerability = true;
							if(!App.ansiColors){								
								_vunerabilityIntel += "Program slice has a vunerability of type " + _vunerabilityType + ".\n"
								+ s.toString() + "\n" 
								+ "Variable with user input: '" + e.getEpVariable() + "', and the query: " + query + "\n"
								+ "Fix: " + _xmlParser.getValidator(s.getSinkPattern()) + "\n";
							}else{
								for(String line : App.fileLines){
									_vunerabilityIntel += line;
									if(line.contains(e.getEpVariable()))
										_vunerabilityIntel += App.ANSI_GREEN + _xmlParser.getValidator(s.getSinkPattern()) + App.ANSI_RESET;
								}
							}
						}
					}
				}
			}
		}
		return vunerability;
	}


	@Override
	protected void doLogic() {
		for(String line : getCodeLines()){		
			_ep = new SQLIEntryPoint(line, _xmlParser.getEntryPoints());
			_sink = new SQLISink(line, _xmlParser.getSinks());
			
			if(!_sink.isSink())
				_sink = null;
			else _sinks.add(_sink);
	
			if(!_ep.isEntryPoint())
				_ep = null;
			else _eps.add(_ep);
	
			if((_ep == null) && (_sink == null)){
				
				if(line.contains("=")){
					
					String[] parsed = line.split("=", 2);
					_querys.put(parsed[0], parsed[1]);
				}
			}
		}
	}
}